#!/bin/bash

#some setup to be save
IFS=$' \t\n'
#some recomended security settings
unset -f unalias
\unalias -a
unset -f command
#more setting to be save
set -o posix;
set -o errexit; set -o errtrace; set -o nounset; set -o pipefail
shopt -s globstar nullglob

#------------------------------------------------------
# get the current directory and write it to currentDir
declare -r currentDir=$(pwd)

#------------------------------------------------------
#get the scripts path and write it into scriptsDir
#realpath is not available in rhel6
if [[ -h $0 ]]; then
	declare -r realCommand=$(readlink -e "$0")
	declare -r commandname="${realCommand##*/}"
	declare -r TTRO_scriptDir="${realCommand%/*}"
else
	tmp="${0%/*}"
	cd "$tmp"
	declare -r TTRO_scriptDir=$(pwd)
	cd "${currentDir}"
	declare -r commandname="${0##*/}"
fi

#---------------------------------------------------
#include the utils define the preliminary trace vars
source "${TTRO_scriptDir}/version.sh"
#declare -x TTPN_debug=""
#declare -x TTPN_debugDisable=""
#declare -x TTPN_verbose=""
#declare -x TTPN_verboseDisable=""

#-----------------------------------------------------
# Shutdown and interrupt vars and functions
declare -i interruptReceived=0

# Function interruptSignalMain
function interruptSignalMain {
	printInfo "SIGINT received in $commandname ********************"
	if [[ $interruptReceived -eq 0 ]]; then
		interruptReceived=1
	else
		printInfo "Abort test"
		exit $errSigint
	fi
	return 0
}

trap interruptSignalMain SIGINT

# Function errorTrapFunc
#	global error exit function - prints the caller stack
function errorTrapFunc {
	echo -e "\033[31mERROR: $FUNCNAME ***************"
	local -i i=0;
	while caller $i; do
		i=$((i+1))
	done
	echo -e "************************************************\033[0m"
}

trap errorTrapFunc ERR
#trap -p

#-----------------------------------------------------
#include the definitions
source "${TTRO_scriptDir}/defs.sh"
source "${TTRO_scriptDir}/mainutil.sh"
source "${TTRO_scriptDir}/util.sh"
source "${TTRO_scriptDir}/coreutil.sh"

#--------------------------------------------------------------------------------------
#The export check - checks whethere there are already vaiables exported with TT prefix
declare exportCheckFailed=""
for x in "${!TTRO_@}"; do
	if [[ $x != TTRO_scriptDir && $x != TTRO_version && $x != TTRO_help* ]]; then
		exportCheckFailed="true"
		printWarning "In environment there are TT scoped identifier: ${x}"
	fi
done
for x in "${!TTPN_@}"; do
	exportCheckFailed="true"
	printWarning "In environment there are TT scoped identifier: ${x}"
done
for x in "${!TTP_@}"; do
	exportCheckFailed="true"
	printWarning "In environment there are TT scoped identifier: ${x}"
done
for x in "${!TT_@}"; do
	exportCheckFailed="true"
	printWarning "In environment there are TT scoped identifier: ${x}"
done

#------------------------------------------------------
#declare all options and option variables the key is also the variable name
declare -r -A singleOptions=(
	['verbose']='-v --verbose'
	['debug']='-d --debug'
	['noChecks']='-n --no-checks'
	['noStart']='--no-start'
	['noStop']='--no-stop'
	['reference']='--ref'
	['flat']='-f --flat'
	['noprompt']='--noprompt'
	['nobrowser']='--no-browser'
)
declare -r -A valueOptions=(
	['workdir']='-w --workdir'
	['directory']='-i --directory'
	['skipIgnore']='-s --skip-ignore'
	['threads']='-j --threads'
)
for x in ${!singleOptions[@]}; do
	declare ${x}=""
done
for x in ${!valueOptions[@]}; do
	declare ${x}=""
done
declare -a toolsFiles=() #The with tools fies to include
declare -a propertyFiles=() # The property files
declare -a varNamesToSet=() #The list with variable names to set
declare -a varValuesToSet=() #The list with variables values to set
declare -a cases=() # the list of cases from command line

#------------------------------------------------------
#set number of cores
declare -r noCpus=$(cat /proc/cpuinfo | grep processor | wc -l)
#getconf _NPROCESSORS_ONLN

#---------------------------------------------------------
if ! declare -p TTPN_debug &> /dev/null; then TTPN_debug=''; fi
if ! declare -p TTPN_debugDisable &> /dev/null; then TTPN_debugDisable=''; fi
if ! declare -p TTPN_verbose &> /dev/null; then TTPN_verbose=''; fi
if ! declare -p TTPN_verboseDisable &> /dev/null; then TTPN_verboseDisable=''; fi

#------------------------------------------------------
# get parametes and set option variables and cases map
declare parametersection="" # we start with options
while [[ $# -ge 1 ]]; do
  case $1 in
	-h|--help )
		[[ -z $parametersection ]] || optionInParamSection $1
		usage
		exit 0;;
	--man)
		[[ -z $parametersection ]] || optionInParamSection $1
		source "${TTRO_scriptDir}/man.sh"
		manpage
		exit 0;;
	--bashhelp)
		[[ -z $parametersection ]] || optionInParamSection $1
		source "${TTRO_scriptDir}/manbash.sh"
		manbashpage
		exit 0;;
	-V|--version)
		[[ -z $parametersection ]] || optionInParamSection $1
		echo "$TTRO_version"
		exit 0;;
	-t|--tools)
		[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
		tmp="${#toolsFiles[@]}"
		toolsFiles[$tmp]="$2"
		shift;;
	-p|--properties)
		[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
		tmp="${#propertyFiles[@]}"
		propertyFiles[$tmp]="$2"
		shift;;
	-D)
		[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
		vname=${2%%=*}
		vvalue=${2#*=}
		if [[ $2 != $vname && $2 != $vvalue ]]; then
			i=${#varNamesToSet[@]}
			varNamesToSet[$i]="$vname"
			varValuesToSet[$i]="$vvalue"
			shift
		else
			printError "Invalid format in parameter -D $2 variable name=$vname variable value=$vvalue"
			usage
			exit ${errInvocation}
		fi;;
	-* )
		[[ -z $parametersection ]] || optionInParamSection $1
		declare optionFound=""
		for option in ${!singleOptions[@]}; do
			for ex in ${singleOptions[$option]}; do
				if [[ $1 == ${ex} ]]; then
					if [[ -n ${!option} ]]; then duplicateOption "${1}"; fi
					eval "${option}=true"
					optionFound="true"
					break 2
				fi
			done
		done
		if [[ -z ${optionFound} ]]; then
			for option in ${!valueOptions[@]}; do
				for ex in ${valueOptions[$option]}; do
					if [[ $1 == ${ex} ]]; then
						if [[ -n ${!option} ]]; then duplicateOption "${1}"; fi
						[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
						eval "${option}=$2"
						optionFound="true"
						shift
						break 2
					fi
				done
			done
		fi
		if [[ -z ${optionFound} ]]; then
			printError "Invalid argument '$1' !!!\n\n"
			usage;
			exit ${errInvocation}
		fi
	;;
	* )
		parametersection="true"
		if [[ $1 == *::?* ]]; then
			n=${#cases[*]}
			cases[$n]="$1"
		else
			printErrorAndExit "Invalid format of test case '$1'.\nTest cases must be in the form suite::case or ::case" ${errInvocation}
		fi
	;;
	esac
	shift
done
unset -v parametersection

#--------------------------------------
# evaluate export check
#if [[ -n "$exportCheckFailed" ]]; then
#	exit ${errRt}
#fi
unset -v exportCheckFailed
#echo "*******************************************************************************************************"
echo  "**** START test case collection ***********************************************************************"
declare -x TTRO_reference=""
if [[ $reference == "true" ]]; then
	TTRO_reference="true"
fi
#---------------------------------------------------------
#set the number of threads to noCpus if not set otherwise
if [[ -z $threads ]]; then
	threads=$noCpus
fi

#---------------------------------------------------------
setVar 'TTPN_debug' "$debug"
setVar 'TTPN_debugDisable' ''
setVar 'TTPN_verbose' "$verbose"
setVar 'TTPN_verboseDisable' ''

#---------------------------------------------------------
# create workdir if necessary and make it absolute
if [[ -z ${workdir} ]]; then
	workdir="${currentDir}/${DEFAULT_WORKDIR}"
fi
if ! mkdir -p ${workdir}; then
	printErrorAndExit "Can not create workdir '${workdir}'" ${errRt}
fi
if cd "${workdir}"; then
	workdir=$(pwd -P)
else
	printErrorAndExit "Invalid workdir '${workdir}' specified" ${errInvocation}
fi
cd "${currentDir}"
#---------------------------------------------------------
# get input directory and make it absolute
if [[ -z ${directory} ]]; then
	printErrorAndExit "No input directory specified" ${errInvocation}
else
	if cd "${directory}"; then
		directory=$(pwd -P)
		declare -x TTRO_inputDir="$directory"
	else
		printErrorAndExit "Invalid directory '${directory}' specified" ${errInvocation}
	fi
	cd "${currentDir}"
fi

#-------------------------------------
#properties file / tools file: if no path element is given use the input dir as prefix
for ((i=0; i<${#propertyFiles[@]}; i++)); do
	tmp="${propertyFiles[$i]}"
	if [[ ${tmp:0:1} != "/" ]]; then
		tmp="${currentDir}/${tmp}"
	fi
	tmp2=$(readlink -m "$tmp")
	propertyFiles[$i]="$tmp2"
done
for ((i=0; i<${#toolsFiles[@]}; i++)); do
	tmp="${toolsFiles[$i]}"
	if [[ ${tmp:0:1} != "/" ]]; then
		tmp="${currentDir}/${tmp}"
	fi
	tmp2=$(readlink -m "$tmp")
	toolsFiles[$i]="$tmp2"
done
readonly propertyFiles toolsFiles

#----------------------------------
#finally make option variables read only
for x in ${!singleOptions[@]}; do
	readonly ${x}
done
for x in ${!valueOptions[@]}; do
	readonly ${x}
done

#-------------------------------------------
# set the global programm defined properties
declare -x TTRO_noParallelCases="$threads"
# declare -x TTRO_noCpus="$noCpus"
if [[ TTRO_noParallelCases -eq 1 ]]; then
	declare -x TTRO_treads="$noCpus"
else
	declare -x TTRO_treads=1
fi

#some more property definitions
for ((i=0; i<${#varNamesToSet[@]}; i++)); do
	declare "${varNamesToSet[$i]}"="${varValuesToSet[$i]}"
done
if [[ $noStart == "true" ]]; then
	setVar TTPN_noStart "true"
	setVar TTPN_noPreps "true"
	setVar TTPN_noPrepsSuite "true"
else
	setVar TTPN_noStart ''
	setVar TTPN_noPreps ''
	setVar TTPN_noPrepsSuite ''
fi
if [[ $noStop == "true" ]]; then
	setVar TTPN_noStop "true"
	setVar TTPN_noFins "true"
	setVar TTPN_noFinsSuite "true"
else
	setVar TTPN_noStop ''
	setVar TTPN_noFins ''
	setVar TTPN_noFinsSuite ''
fi
setVar TTPN_noPrepsCase ''
setVar TTPN_noFinsCase ''
fixPropsVars

#--------------------------------
# Programm entry
printParams

#-----------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------
# Check test properies file if properties parameter was given
for ((i=0; i<${#propertyFiles[@]}; i++)) do
	x="$${propertyFiles[$i]}"
	if [[ -r "$x" ]]; then
		isVerbose && printVerbose "Found readable test properties file $x"
	else
		printErrorAndExit "No test properties file $x found"
	fi
done

#-----------------------------------------------------------------------------------------
# search test suites. Suites are directories with a suite definition file $TEST_SUITE_FILE
# globals for searches
declare suitesIndex=0      #the global index of the next suite
declare -a suitesPath=()   #the array with all suites pathes
declare -a suitesName=()   #the logical name of the suite (is the r-path from parent element if no link is involved)
declare -a executeSuite=() #true if this suite is to execute
declare -a childSuites=()  #the array with the list of all sub-suite indexes for every suite index
declare casesIndex=0       #the global index of the next case
declare -a casesPath=()    #the array with all case pathes
declare -a casesName=()    #the logical name of the case
declare -a executeCase=()  #execute the case
declare -a childCases=()   #the array with the list of all case indexes for each suite index
declare noCases=0          #number of found cases
declare noSuites=0         #number of found suites
if [[ -z $TTRO_reference ]]; then
	#initialize the globals for dummy suite
	suitesIndex=1             #dummy suite is index 0
	suitesPath[0]="$TTRO_inputDir" #the dummy suite path
	suitesName[0]=''
	childSuites[0]=''
	childCases[0]=''
	executeSuite[0]=''
	#global level 0 cild suites counter
	declare childSuitesIndex=0
	scan "$TTRO_inputDir" "0"
fi
declare -r noSuites=$((suitesIndex-1))
declare -r noCases="$casesIndex"
isDebug && printDebug "$noSuites suites found and $noCases cases found"
# print suites
if isDebug; then
	printDebug "******************* test suites/cases found in $TTRO_inputDir *******************"
	printSuitesCases 0 0 '' 'true'
	printDebug "*********************************************************************************"
	declare -p suitesPath
	declare -p suitesName
	declare -p childSuites
	declare -p childCases
	declare -p casesPath
	declare -p casesName
fi

#------------------------------------------
#The final list with test cases to execute
declare -i noCasesToExecute=0
declare -i noSuitesToExecute=0
declare usedCaseIndexList=''
#if the command line has no case list, all found cases are executed
#otherwise all matching cases found are executed
#if there is a case list on the command line, the skip attributes of test cases and suites are ignored
if [[ ${#cases[@]} -eq 0 ]]; then
	#the command line specified no cases -> all found cases are executed
	#and skip attributes are honoured
	if [[ -n ${skipIgnore} ]]; then
		declare -rx TTRO_skipIgnore="true"
	else
		declare -rx TTRO_skipIgnore=""
	fi
	takeAllCases="true"
	for ((i=0; i<${#executeSuite[@]}; i++)); do
		executeSuite[$i]='true'
	done
	for ((i=0; i<${#executeCase[@]}; i++)); do
		executeCase[$i]='true'
	done
else
	#the command line specifies a cases list
	declare -rx TTRO_skipIgnore="true"
	takeAllCases=""
	declare caseToExecuteParent=''
	checkCaseMatch '0' '0' '' ''
	#if [[ -n $caseToExecuteParent ]]; then
	#dummy suite is always executed
	executeSuite[0]='true'
	#fi
fi
declare -p executeSuite
declare -p executeCase

for ((i=0; i<${#executeSuite[@]}; i++)); do
	if [[ -n ${executeSuite[$i]} ]]; then
		noSuitesToExecute=$((noSuitesToExecute+1))
	fi
done

#--------------------------------------------------
#check whether cases from input list are not found
for x in ${!cases[@]}; do
	patternMatchWasFound=''
	for y in $usedCaseIndexList; do
		if [[ $x == $y ]]; then
			patternMatchWasFound='true'
			break
		fi
	done
	if [[ -z $patternMatchWasFound ]]; then
		printWarning "Case ${cases[$x]} from parameter list was not found in input directory ${directory}"
	fi
done

#--------------------------------------------------
#guard the lists
readonly suitesIndex suitesPath suitesName executeSuite childSuites
readonly casesPath casesName executeCase childCases

readonly noCases noSuites noCasesToExecute noSuitesToExecute

#--------------------------------------------------
# print final execution list and prompt
printInfo "******************* $noSuitesToExecute suites (incl dummy) and $noCasesToExecute cases to execute in $TTRO_inputDir *******************"
printSuitesCases 0 0 'true' ''

echo "********************************************************"
if [[ -z $noprompt && -z $TTRO_reference ]]; then
	while read -p "Continue or exit? y/e "; do
		if [[ $REPLY == y* || $REPLY == Y* || $REPLY == c* || $REPLY == C* ]]; then
			break
		elif [[ $REPLY == e* || $REPLY == E* || $REPLY == n* || $REPLY == N* ]]; then
			exit $errScript
		fi
	done
fi

#######################################################################################
#echo "*******************************************************************************************************"
declare -xr TTRO_collection="${TTRO_inputDir##*/}"
printInfo  "**** START: Test execution collection $TTRO_collection ******************************************************************"
#-----------------------
#export execution lists
export TTXX_suitesPath=$(declare -p suitesPath)
export TTXX_suitesName=$(declare -p suitesName)
export TTXX_executeSuite=$(declare -p executeSuite)
export TTXX_childSuites=$(declare -p childSuites)
export TTXX_casesPath=$(declare -p casesPath)
export TTXX_casesName=$(declare -p casesName)
export TTXX_executeCase=$(declare -p executeCase)
export TTXX_childCases=$(declare -p childCases)

#----------------
#make output dir
if [[ $flat == 'true' ]]; then
	TTRO_workDir="${workdir}"
else
	datestring=$(date +%Y%m%d-%H%M%S)
	TTRO_workDir="${workdir}/${datestring}"
fi
if [[ $flat != 'true' && -e $TTRO_workDir ]]; then
	printErrorAndExit "Output directory already exists $TTRO_workDir" $errRt
fi
if [[ -e $TTRO_workDir ]]; then
	if [[ $noprompt == "true" ]]; then
		rm -rf "$TTRO_workDir"
	else
		while read -p "WARNING: Output directory already exists $TTRO_workDir: Remove it or not or exit? y/n/e "; do
			if [[ $REPLY == y* || $REPLY == Y* ]]; then
				rm -rf "$TTRO_workDir"
				break
			elif [[ $REPLY == n* || $REPLY == N* ]]; then
				break
			elif [[ $REPLY == e* || $REPLY == E* ]]; then
				exit $errScript
			fi
		done
	fi
fi
mkdir -p "$TTRO_workDir"
printInfo "TTRO_workDir=$TTRO_workDir"

#------------------------------------------------
# enter working dir
cd "$TTRO_workDir"

#-----------------------------------------------------------
#check if properties file exists - read properties and fixup
if [[ ${#propertyFiles[@]} -gt 0 ]]; then
	for ((i=0; i<${#propertyFiles[@]}; i++)); do
		x="${propertyFiles[$i]}"
		isVerbose && printVerbose "Include global properties $x"
		source "${x}"
	done
elif [[ -e "$TTRO_inputDir/$TEST_PROPERTIES" ]]; then
	isVerbose && printVerbose "Include global properties $TTRO_inputDir/$TEST_PROPERTIES"
	source "$TTRO_inputDir/$TEST_PROPERTIES"
else
	isVerbose && printVerbose "No global properies file to evaluate"
fi
fixPropsVars # fix global properties and vars
writeProtectExportedFunctions

#------------------------------------------------
# source tools
declare -x TTXX_tools=''
if [[ ${#toolsFiles[@]} -gt 0 ]]; then
	for ((i=0; i<${#toolsFiles[@]}; i++)); do
		x="${toolsFiles[$i]}"
		isVerbose && printVerbose "Source global tools file: $x"
		if [[ -r $x ]]; then
			import "$x"
		else
			printErrorAndExit "Tools file $x is required but this file is not readable" $errRt
		fi
	done
else
	isDebug && printDebug "No additional global test tools files defined"
fi
fixPropsVars # fix global properties and var
writeProtectExportedFunctions

#-----------------------------------------------
if [[ -n $TTRO_reference ]]; then
	list=$(echo "${!TTRO_help@} " | sort)
	{
		for x in $list; do
			name="${x#TTRO_help_}"
			echo "#######################################"
			echo -n "#		$name"
			echo "${!x}"
			echo
			echo
		done
	} | less
	exit 0
fi

#------------------------------------------------
# diagnostics
isVerbose && printTestframeEnvironment
tmp="${TTRO_workDir}/${TEST_ENVIRONMET_LOG}"
printTestframeEnvironment > "$tmp"
export >> "$tmp"

#--------------------------------------------
#execution loop over suites and variants
declare -i suiteVariants=0 suiteErrors=0
if [[ $interruptReceived -eq 0 ]]; then
	isVerbose && printVerbose "**** START Root Suite ************************************"
	exeSuite '0' '' '-1' '' '' "${TTRO_workDir}"
	isVerbose && printVerbose "**** END Root Suite **************************************"
fi

#print result lists
printInfo  "**** END Test execution *******************************************************************************"
for x in CASE_EXECUTE CASE_SKIP CASE_FAILURE CASE_ERROR CASE_SUCCESS SUITE_EXECUTE SUITE_SKIP SUITE_ERROR; do
	tmp="${TTRO_workDir}/${x}"
	eval "${x}Count=0"
	if isVerbose || [[ $x == *_FAILURE || $x == *_ERROR ]]; then printVerbose "**** $x List : ****"; fi
	if [[ -e ${tmp} ]]; then
		{
			while read; do
				if isVerbose || [[ $x == *_FAILURE || $x == *_ERROR ]]; then printVerbose "$REPLY "; fi
				if [[ $REPLY != \#* ]]; then
					eval "${x}Count=\$((\${x}Count+1))"
				fi
			done
		} < "$tmp"
	else
		printErrorAndExit "No result file ${tmp} exists" $errRt
	fi
done
#put results to results file for information purose only 
#echo -e "VARIANT=$VARIANTCount\nSUCCESS=$SUCCESSCount\nSKIP=$SKIPCount\nFAILURE=$FAILURECount\nERROR=$ERRORCount" > "${TTRO_workDir}/RESULT"
#echo -e "SUITE_VARIANT=$SUITE_VARIANTCount SUITE_ERROR=$SUITE_ERRORCount"

#Print suite errors and collection
if [[ $SUITE_ERRORCount -gt 0 ]]; then
	printError "Errors in $SUITE_ERRORCount suites:"
	cat "$TTRO_workDir/SUITE_ERROR"
fi

indexfilename="${TTRO_workDir}/index.html"
echo
printf "*******************************************************************************************************\n"
printf "***** suites executed=%i skipped=%i errors=%i\n" $SUITE_EXECUTECount $SUITE_SKIPCount $SUITE_ERRORCount
printf "***** cases  executed=%i skipped=%i failures=%i errors=%i\n" $CASE_EXECUTECount $CASE_SKIPCount $CASE_FAILURECount $CASE_ERRORCount
printf "***** used workdir: %s\n" "$TTRO_workDir"
printf "***** Index in %s\n" "$indexfilename"
printf "*******************************************************************************************************\n"

#--------------------------------------------
# prepare html docs
#createCSS "${TTRO_workDir}/testframe.css"
createGlobalIndex "$indexfilename"

declare mainResult=0
if [[ $interruptReceived -ne 0 ]]; then
	mainResult=$errSigint
elif [[ $SUITE_ERRORCount -gt 0 ]]; then
	mainResult=$errSuiteError
elif [[ $CASE_ERRORCount -gt 0 ]]; then
	mainResult=$errTestError
elif [[ $CASE_FAILURECount -gt 0 ]]; then
	mainResult=$errTestFail
fi

builtin echo -n "$mainResult" > "$TTRO_workDir/DONE"

if [[ -z $nobrowser ]]; then
	tmp='firefox'
	if isExisting 'BROWSER'; then
		tmp="$BROWSER"
	fi
	if [[ -z $tmp ]]; then
		isVerbose && printVerbose "Empty BROWSER variable: no browser started"
	else
		if ! startAsync2 "$tmp" "$indexfilename"; then
			printError "Browser command $tmp failed"
		fi
	fi
fi

exit $mainResult
